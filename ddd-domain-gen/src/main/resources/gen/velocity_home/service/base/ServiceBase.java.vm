package ${rootPackage}.domain.${meta.domainName}.model.${meta.class_name};

import com.github.pagehelper.PageInfo;
import ${rootPackage}.infrastructure.general.common.Constants;
import ${rootPackage}.infrastructure.general.common.interfaces.BaseService;
import ${rootPackage}.infrastructure.persistent.service.repo.RepoService;
import org.springframework.cache.annotation.CacheConfig;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.List;

@CacheConfig(cacheNames = "${meta.ClassName}Service", keyGenerator = Constants.KEY_GENERATOR)
public abstract class ${meta.ClassName}ServiceBase implements BaseService<${meta.ClassName}Entity> {
    @Resource
    RepoService repoService;

    @Transactional(readOnly = true)
    @Cacheable(keyGenerator = Constants.KEY_GENERATOR_TO_SERVICE_PARAM)
    public ${meta.ClassName}Entity findById(Long id) {
        ${meta.ClassName}Entity entity = new ${meta.ClassName}Entity();
        entity.setId(id);
        return repoService.findById(entity);
    }

    @Transactional(readOnly = true)
    @Cacheable(keyGenerator = Constants.KEY_GENERATOR_TO_SERVICE_PARAM)
    public PageInfo<${meta.ClassName}Entity> queryPage(${meta.ClassName}Entity entity, int pageNum, int pageSize) {
        PageInfo<${meta.ClassName}Entity> pageInfo = repoService.queryPage(entity, pageNum, pageSize);
        return pageInfo;
    }

    @Transactional(readOnly = true)
    @Cacheable(keyGenerator = Constants.KEY_GENERATOR_TO_SERVICE_PARAM)
    public List<${meta.ClassName}Entity> queryList(${meta.ClassName}Entity entity, int pageSize) {
        return repoService.queryList(entity, pageSize);
    }

    @Transactional(rollbackFor = Exception.class)
    @CacheEvict(allEntries = true, beforeInvocation = false)
    public ${meta.ClassName}Entity insert(${meta.ClassName}Entity entity) {
        return repoService.insert(entity);
    }

    @Transactional(rollbackFor = Exception.class)
    @CacheEvict(allEntries = true, beforeInvocation = false)
    public boolean update(${meta.ClassName}Entity entity) {
        return repoService.updateById(entity);
    }

    @Transactional(rollbackFor = Exception.class)
    @CacheEvict(allEntries = true, beforeInvocation = false)
    public boolean deleteById(${meta.ClassName}Entity entity) {
        return repoService.deleteById(entity);
    }

    @CacheEvict(allEntries = true, beforeInvocation = false)
    public void cacheEvict() {
    }
}
